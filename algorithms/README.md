# Algorithms

During the algorithm course, the following algorithms were implemented (and learned):

They were sorted from the first theme to the last.

- #### Binary search
    - [Square and rectangles](./square_and_rectangles.cpp) to find the square of the intersection of the given rectangles.
    - [Quick search in the array](./quick_search_in_array.cpp) to find the number of numbers which have values from l to r.
    - [Lovers of statistics](./lovers_of_statistics.cpp) to find among cities with numbers from l to r, such that during the year, the trams of these cities transported exactly x people.
    - [Ropes](./ropes.cpp) to answer the question: "Is it possible to divide n given ropes into k ropes of the same length?"
    - [Elevator](./elevator.cpp) to find the maximum number of people the elevator can take to the parking lot in T seconds, if the number of people on each floor is known.

- #### Minimums
    - [Minimum in submatrices](./minimums_in_submatrices.cpp) in a given window using a stack.
    - [Memory management](./memory_management.cpp) to allocate memory most effectively using a deque and a priority queue.

- #### Sweep line
    - [Tom Sawyer.cpp](./tom_sawyer.cpp) to find the final number of fence sections for each color (if it is painted many times).

- #### Depth-first search
    - [The longest path](./the_longest_path.cpp) finds the longest path in a given weighted graph such that each vertex of the graph occurs in it at most once (using dynamic programming).
    - [Bridges and components](./bridges_and_components.cpp) finds costal doubly-linked components.
    - [Unique topsort](./unique_topsort.cpp) checks whether topsort is unique or not.
    - [The king](./the_king.cpp) finds the number of vertices that are on all possible paths between s and t.
    - [Chip Installation](./chip_installation.cpp) solves 2-SAT through a graph.

- #### Breadth-first search
    - [Shortest path of the knight](./shortest_path_of_knight.cpp) to find the shortest path for a knight in chess from s to t.

- #### Dijkstra
    - [Island countries](./island_countries.cpp) finds the cheapest path from one city to another.

- #### Floyd-Warshall
    - [Transitive closure](./transitive_closure.cpp).
    - [Floyd](./floyd.cpp) is just a Floyd algorithm implementation.

- #### Bellman-Ford
    - [Maze of knowledge](./maze_of_knowledge.cpp) to find the most expensive path.

- #### Minimum spanning tree
    - [Swamp](./swamp.cpp) minimum spanning tree + dfs.

- #### Scheduling algorithms (1sumu)
    - [Snow White](./snowwhite.cpp) finds the most optimal schedule.
    - [Weights](./weights.cpp) has a complex clause, therefore I provide the translation:

        Tolik came up with a new programming technology. He wants to persuade his friends to use it. The i-th friend will agree to use Tolik's technology if his authority is not less than a_i (some integer). As soon as the i-th friend starts using it, the number b_i will be added to Tolik's authority (there are people who have b_i < 0). Help Tolik guide as many of his friends on the right path as possible.
    - [Adventure](./adventure.cpp) The students fell into a pit. It is necessary to find the configuration of the turret of students so that the maximum number of people can get out of the pit.

- #### Cartesian tree
    - [K-maximum](./k-maximum.cpp) to find the k maximum in a sorted array.
    - [Sum again.cpp](./sum_again.cpp) set of integers, which allows adding.
    - [Range minimum query](./range_minimum_query.cpp) to find the minimum in the range [l, r] in O(log n) time and add after the i-th position in logarithmic time.

- #### Least common ancestor (LCA)
    - [Tree](./tree.cpp) to find the shortest distance between two vertices in a weighted tree.

- #### Persistent Data Structures
    - [Persistent queue](./persistent_queue.cpp).

- #### Gaussian elimination
    - [Inside out](./inside_out.cpp), [vectors](./vectors.cpp) implement bitwise Gaussian elimination without swapping rows.
    - [Nikifor](./nikifor.cpp) to find whether the linear system is independent or not.

- #### Min cut/max flow (Dinitz algorithm)
    - [Perfect matching](./perfect_matching.cpp) in a bipartite graph.
    - [Minimal_vertex_cover](./minimal_vertex_cover.cpp) in a bipartite graph given a perfect matching.
    - [Taxi](./taxi.cpp) to find the minimum required number of taxis for a certain schedule.
    - [Perspective](./perspective.cpp) to find the possible outcome given tournament brackets.
    - [Snails](./snails.cpp) to find two different ways from s to t.

- #### Prefix- and z-functions
    - [Suffixes](./suffixes.cpp) to find the position of a suffix in the cycled suffix array.
    - [Blocks](./blocks.cpp) to find palindromes.
    - [Archivator](./archivator.cpp) is an algorithm to encode the string "aaaabaab" as "a, 1 3, b, 3 3". If a character sequence already exists, it addresses the beginning of the character sequence and its length.
    - [String basis](./string_basis.cpp) to find the period of the string that is repeated many times.
